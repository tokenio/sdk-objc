// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fank/cma9.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "fank/Cma9.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - Cma9Root

@implementation Cma9Root

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - Cma9Root_FileDescriptor

static GPBFileDescriptor *Cma9Root_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"io.token.proto.cma9"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PaymentContextCode

GPBEnumDescriptor *PaymentContextCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidCode\000BillPayment\000EcommerceGoods\000E"
        "commerceServices\000Other\000PersonToPerson\000";
    static const int32_t values[] = {
        PaymentContextCode_InvalidCode,
        PaymentContextCode_BillPayment,
        PaymentContextCode_EcommerceGoods,
        PaymentContextCode_EcommerceServices,
        PaymentContextCode_Other,
        PaymentContextCode_PersonToPerson,
    };
    static const char *extraTextFormatInfo = "\006\000\013\000\001\013\000\002\016\000\003\021\000\004\005\000\005\016\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PaymentContextCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PaymentContextCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PaymentContextCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PaymentContextCode_InvalidCode:
    case PaymentContextCode_BillPayment:
    case PaymentContextCode_EcommerceGoods:
    case PaymentContextCode_EcommerceServices:
    case PaymentContextCode_Other:
    case PaymentContextCode_PersonToPerson:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AccountSchemeName

GPBEnumDescriptor *AccountSchemeName_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidAccountSchemeName\000Iban\000SortCodeAc"
        "countNumber\000";
    static const int32_t values[] = {
        AccountSchemeName_InvalidAccountSchemeName,
        AccountSchemeName_Iban,
        AccountSchemeName_SortCodeAccountNumber,
    };
    static const char *extraTextFormatInfo = "\002\000\030\000\002\025\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountSchemeName)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountSchemeName_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountSchemeName_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountSchemeName_InvalidAccountSchemeName:
    case AccountSchemeName_Iban:
    case AccountSchemeName_SortCodeAccountNumber:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AccountPermission

GPBEnumDescriptor *AccountPermission_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidPermission\000ReadAccountsBasic\000Read"
        "AccountsDetail\000ReadBalances\000ReadBenefici"
        "ariesBasic\000ReadBeneficiariesDetail\000ReadD"
        "irectDebits\000ReadProducts\000ReadStandingOrd"
        "ersBasic\000ReadStandingOrdersDetail\000ReadTr"
        "ansactionsBasic\000ReadTransactionsCredits\000"
        "ReadTransactionsDebits\000ReadTransactionsD"
        "etail\000";
    static const int32_t values[] = {
        AccountPermission_InvalidPermission,
        AccountPermission_ReadAccountsBasic,
        AccountPermission_ReadAccountsDetail,
        AccountPermission_ReadBalances,
        AccountPermission_ReadBeneficiariesBasic,
        AccountPermission_ReadBeneficiariesDetail,
        AccountPermission_ReadDirectDebits,
        AccountPermission_ReadProducts,
        AccountPermission_ReadStandingOrdersBasic,
        AccountPermission_ReadStandingOrdersDetail,
        AccountPermission_ReadTransactionsBasic,
        AccountPermission_ReadTransactionsCredits,
        AccountPermission_ReadTransactionsDebits,
        AccountPermission_ReadTransactionsDetail,
    };
    static const char *extraTextFormatInfo = "\016\000\021\000\001\021\000\002\022\000\003\014\000\004\026\000\005\027\000\006\020\000\007\014\000\010\027\000\t\030\000\n\025\000\013\027\000\014\026\000\r\026\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountPermission)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountPermission_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountPermission_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountPermission_InvalidPermission:
    case AccountPermission_ReadAccountsBasic:
    case AccountPermission_ReadAccountsDetail:
    case AccountPermission_ReadBalances:
    case AccountPermission_ReadBeneficiariesBasic:
    case AccountPermission_ReadBeneficiariesDetail:
    case AccountPermission_ReadDirectDebits:
    case AccountPermission_ReadProducts:
    case AccountPermission_ReadStandingOrdersBasic:
    case AccountPermission_ReadStandingOrdersDetail:
    case AccountPermission_ReadTransactionsBasic:
    case AccountPermission_ReadTransactionsCredits:
    case AccountPermission_ReadTransactionsDebits:
    case AccountPermission_ReadTransactionsDetail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CreditDebit

GPBEnumDescriptor *CreditDebit_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidIndicator\000Credit\000Debit\000";
    static const int32_t values[] = {
        CreditDebit_InvalidIndicator,
        CreditDebit_Credit,
        CreditDebit_Debit,
    };
    static const char *extraTextFormatInfo = "\003\000\020\000\001\006\000\002\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CreditDebit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CreditDebit_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CreditDebit_IsValidValue(int32_t value__) {
  switch (value__) {
    case CreditDebit_InvalidIndicator:
    case CreditDebit_Credit:
    case CreditDebit_Debit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PaymentAgentSchemeName

GPBEnumDescriptor *PaymentAgentSchemeName_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidAgentSchemeName\000Bicfi\000";
    static const int32_t values[] = {
        PaymentAgentSchemeName_InvalidAgentSchemeName,
        PaymentAgentSchemeName_Bicfi,
    };
    static const char *extraTextFormatInfo = "\001\000\026\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PaymentAgentSchemeName)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PaymentAgentSchemeName_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PaymentAgentSchemeName_IsValidValue(int32_t value__) {
  switch (value__) {
    case PaymentAgentSchemeName_InvalidAgentSchemeName:
    case PaymentAgentSchemeName_Bicfi:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DeliveryAddress

@implementation DeliveryAddress

@dynamic addressLineArray, addressLineArray_Count;
@dynamic buildingNumber;
@dynamic country;
@dynamic countrySubDivisionArray, countrySubDivisionArray_Count;
@dynamic postCode;
@dynamic streetName;
@dynamic townName;

typedef struct DeliveryAddress__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressLineArray;
  NSString *buildingNumber;
  NSString *country;
  NSMutableArray *countrySubDivisionArray;
  NSString *postCode;
  NSString *streetName;
  NSString *townName;
} DeliveryAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressLineArray",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_AddressLineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, addressLineArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildingNumber",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_BuildingNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, buildingNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_Country,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "countrySubDivisionArray",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_CountrySubDivisionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, countrySubDivisionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postCode",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_PostCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, postCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streetName",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_StreetName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, streetName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "townName",
        .dataTypeSpecific.className = NULL,
        .number = DeliveryAddress_FieldNumber_TownName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeliveryAddress__storage_, townName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeliveryAddress class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeliveryAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\000AddressLine\000\002N\000\003G\000\004\000CountrySubDivisio"
        "n\000\005H\000\006J\000\007H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Risk

@implementation Risk

@dynamic hasDeliveryAddress, deliveryAddress;
@dynamic merchantCategoryCode;
@dynamic merchantCustomerIdentification;
@dynamic paymentContextCode;

typedef struct Risk__storage_ {
  uint32_t _has_storage_[1];
  PaymentContextCode paymentContextCode;
  DeliveryAddress *deliveryAddress;
  NSString *merchantCategoryCode;
  NSString *merchantCustomerIdentification;
} Risk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deliveryAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(DeliveryAddress),
        .number = Risk_FieldNumber_DeliveryAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Risk__storage_, deliveryAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "merchantCategoryCode",
        .dataTypeSpecific.className = NULL,
        .number = Risk_FieldNumber_MerchantCategoryCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Risk__storage_, merchantCategoryCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "merchantCustomerIdentification",
        .dataTypeSpecific.className = NULL,
        .number = Risk_FieldNumber_MerchantCustomerIdentification,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Risk__storage_, merchantCustomerIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentContextCode",
        .dataTypeSpecific.enumDescFunc = PaymentContextCode_EnumDescriptor,
        .number = Risk_FieldNumber_PaymentContextCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Risk__storage_, paymentContextCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Risk class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Risk__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001O\000\002T\000\003^\000\004R\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Risk_PaymentContextCode_RawValue(Risk *message) {
  GPBDescriptor *descriptor = [Risk descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Risk_FieldNumber_PaymentContextCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRisk_PaymentContextCode_RawValue(Risk *message, int32_t value) {
  GPBDescriptor *descriptor = [Risk descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Risk_FieldNumber_PaymentContextCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Links

@implementation Links

@dynamic first;
@dynamic last;
@dynamic next;
@dynamic prev;
@dynamic self_p;

typedef struct Links__storage_ {
  uint32_t _has_storage_[1];
  NSString *first;
  NSString *last;
  NSString *next;
  NSString *prev;
  NSString *self_p;
} Links__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "first",
        .dataTypeSpecific.className = NULL,
        .number = Links_FieldNumber_First,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Links__storage_, first),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "last",
        .dataTypeSpecific.className = NULL,
        .number = Links_FieldNumber_Last,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Links__storage_, last),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "next",
        .dataTypeSpecific.className = NULL,
        .number = Links_FieldNumber_Next,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Links__storage_, next),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prev",
        .dataTypeSpecific.className = NULL,
        .number = Links_FieldNumber_Prev,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Links__storage_, prev),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "self_p",
        .dataTypeSpecific.className = NULL,
        .number = Links_FieldNumber_Self_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Links__storage_, self_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Links class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Links__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001E\000\002D\000\003D\000\004D\000\005\000Self\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Meta

@implementation Meta

@dynamic totalPages;

typedef struct Meta__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalPages;
} Meta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalPages",
        .dataTypeSpecific.className = NULL,
        .number = Meta_FieldNumber_TotalPages,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Meta__storage_, totalPages),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Meta class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Meta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRequestSetup

@implementation AccountRequestSetup

@dynamic expirationDateTime;
@dynamic permissionsArray, permissionsArray_Count;
@dynamic transactionFromDateTime;
@dynamic transactionToDateTime;

typedef struct AccountRequestSetup__storage_ {
  uint32_t _has_storage_[1];
  NSString *expirationDateTime;
  GPBEnumArray *permissionsArray;
  NSString *transactionFromDateTime;
  NSString *transactionToDateTime;
} AccountRequestSetup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "expirationDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestSetup_FieldNumber_ExpirationDateTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRequestSetup__storage_, expirationDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = AccountPermission_EnumDescriptor,
        .number = AccountRequestSetup_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountRequestSetup__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transactionFromDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestSetup_FieldNumber_TransactionFromDateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountRequestSetup__storage_, transactionFromDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionToDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestSetup_FieldNumber_TransactionToDateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountRequestSetup__storage_, transactionToDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRequestSetup class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRequestSetup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001R\000\002\000Permissions\000\003W\000\004U\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRequestData

@implementation AccountRequestData

@dynamic accountRequestId;
@dynamic creationDateTime;
@dynamic expirationDateTime;
@dynamic permissionsArray, permissionsArray_Count;
@dynamic status;
@dynamic transactionFromDateTime;
@dynamic transactionToDateTime;

typedef struct AccountRequestData__storage_ {
  uint32_t _has_storage_[1];
  AccountRequestData_AccountRequestStatus status;
  NSString *accountRequestId;
  NSString *creationDateTime;
  NSString *expirationDateTime;
  GPBEnumArray *permissionsArray;
  NSString *transactionFromDateTime;
  NSString *transactionToDateTime;
} AccountRequestData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountRequestId",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestData_FieldNumber_AccountRequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, accountRequestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creationDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestData_FieldNumber_CreationDateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, creationDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expirationDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestData_FieldNumber_ExpirationDateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, expirationDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = AccountPermission_EnumDescriptor,
        .number = AccountRequestData_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = AccountRequestData_AccountRequestStatus_EnumDescriptor,
        .number = AccountRequestData_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transactionFromDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestData_FieldNumber_TransactionFromDateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, transactionFromDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionToDateTime",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequestData_FieldNumber_TransactionToDateTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AccountRequestData__storage_, transactionToDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRequestData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRequestData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001P\000\002P\000\003R\000\004\000Permissions\000\005F\000\006W\000\007U\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AccountRequestData_Status_RawValue(AccountRequestData *message) {
  GPBDescriptor *descriptor = [AccountRequestData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccountRequestData_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetAccountRequestData_Status_RawValue(AccountRequestData *message, int32_t value) {
  GPBDescriptor *descriptor = [AccountRequestData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccountRequestData_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AccountRequestData_AccountRequestStatus

GPBEnumDescriptor *AccountRequestData_AccountRequestStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Authorised\000AwaitingAuthorisation"
        "\000Rejected\000Revoked\000";
    static const int32_t values[] = {
        AccountRequestData_AccountRequestStatus_Invalid,
        AccountRequestData_AccountRequestStatus_Authorised,
        AccountRequestData_AccountRequestStatus_AwaitingAuthorisation,
        AccountRequestData_AccountRequestStatus_Rejected,
        AccountRequestData_AccountRequestStatus_Revoked,
    };
    static const char *extraTextFormatInfo = "\005\000\007\000\001\n\000\002\025\000\003\010\000\004\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountRequestData_AccountRequestStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountRequestData_AccountRequestStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountRequestData_AccountRequestStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountRequestData_AccountRequestStatus_Invalid:
    case AccountRequestData_AccountRequestStatus_Authorised:
    case AccountRequestData_AccountRequestStatus_AwaitingAuthorisation:
    case AccountRequestData_AccountRequestStatus_Rejected:
    case AccountRequestData_AccountRequestStatus_Revoked:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MetaData

@implementation MetaData

@dynamic firstAvailableDateTime;
@dynamic lastAvailableDateTime;
@dynamic totalPages;

typedef struct MetaData__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalPages;
  NSString *firstAvailableDateTime;
  NSString *lastAvailableDateTime;
} MetaData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstAvailableDateTime",
        .dataTypeSpecific.className = NULL,
        .number = MetaData_FieldNumber_FirstAvailableDateTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MetaData__storage_, firstAvailableDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastAvailableDateTime",
        .dataTypeSpecific.className = NULL,
        .number = MetaData_FieldNumber_LastAvailableDateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MetaData__storage_, lastAvailableDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalPages",
        .dataTypeSpecific.className = NULL,
        .number = MetaData_FieldNumber_TotalPages,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MetaData__storage_, totalPages),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001V\000\002U\000\003J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Servicer

@implementation Servicer

@dynamic identification;
@dynamic schemeName;

typedef struct Servicer__storage_ {
  uint32_t _has_storage_[1];
  Servicer_ServicerSchemeName schemeName;
  NSString *identification;
} Servicer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = Servicer_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Servicer__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = Servicer_ServicerSchemeName_EnumDescriptor,
        .number = Servicer_FieldNumber_SchemeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Servicer__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Servicer class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Servicer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001N\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Servicer_SchemeName_RawValue(Servicer *message) {
  GPBDescriptor *descriptor = [Servicer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Servicer_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetServicer_SchemeName_RawValue(Servicer *message, int32_t value) {
  GPBDescriptor *descriptor = [Servicer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Servicer_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Servicer_ServicerSchemeName

GPBEnumDescriptor *Servicer_ServicerSchemeName_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Bicfi\000";
    static const int32_t values[] = {
        Servicer_ServicerSchemeName_Invalid,
        Servicer_ServicerSchemeName_Bicfi,
    };
    static const char *extraTextFormatInfo = "\001\000\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Servicer_ServicerSchemeName)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Servicer_ServicerSchemeName_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Servicer_ServicerSchemeName_IsValidValue(int32_t value__) {
  switch (value__) {
    case Servicer_ServicerSchemeName_Invalid:
    case Servicer_ServicerSchemeName_Bicfi:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AccountDetails

@implementation AccountDetails

@dynamic identification;
@dynamic name;
@dynamic schemeName;
@dynamic secondaryIdentification;

typedef struct AccountDetails__storage_ {
  uint32_t _has_storage_[1];
  AccountSchemeName schemeName;
  NSString *identification;
  NSString *name;
  NSString *secondaryIdentification;
} AccountDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetails_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetails_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = AccountSchemeName_EnumDescriptor,
        .number = AccountDetails_FieldNumber_SchemeName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secondaryIdentification",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetails_FieldNumber_SecondaryIdentification,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, secondaryIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountDetails class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001N\000\002D\000\003J\000\004W\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AccountDetails_SchemeName_RawValue(AccountDetails *message) {
  GPBDescriptor *descriptor = [AccountDetails descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccountDetails_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetAccountDetails_SchemeName_RawValue(AccountDetails *message, int32_t value) {
  GPBDescriptor *descriptor = [AccountDetails descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccountDetails_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Account

@implementation Account

@dynamic hasAccount, account;
@dynamic accountId;
@dynamic currency;
@dynamic nickname;
@dynamic hasServicer, servicer;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  AccountDetails *account;
  NSString *accountId;
  NSString *currency;
  NSString *nickname;
  Servicer *servicer;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountDetails),
        .number = Account_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, account),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Currency,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, currency),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Nickname,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, nickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "servicer",
        .dataTypeSpecific.className = GPBStringifySymbol(Servicer),
        .number = Account_FieldNumber_Servicer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account__storage_, servicer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001G\000\002I\000\003H\000\004H\000\005H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountData

@implementation AccountData

@dynamic accountArray, accountArray_Count;

typedef struct AccountData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *accountArray;
} AccountData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account),
        .number = AccountData_FieldNumber_AccountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountData__storage_, accountArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Account\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Balance

@implementation Balance

@dynamic accountId;
@dynamic hasAmount, amount;
@dynamic creditDebitIndicator;
@dynamic dateTime;
@dynamic type;

typedef struct Balance__storage_ {
  uint32_t _has_storage_[1];
  CreditDebit creditDebitIndicator;
  Balance_BalanceType type;
  NSString *accountId;
  InstructedAmount *amount;
  NSString *dateTime;
} Balance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Balance_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Balance__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = GPBStringifySymbol(InstructedAmount),
        .number = Balance_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Balance__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "creditDebitIndicator",
        .dataTypeSpecific.enumDescFunc = CreditDebit_EnumDescriptor,
        .number = Balance_FieldNumber_CreditDebitIndicator,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Balance__storage_, creditDebitIndicator),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dateTime",
        .dataTypeSpecific.className = NULL,
        .number = Balance_FieldNumber_DateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Balance__storage_, dateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Balance_BalanceType_EnumDescriptor,
        .number = Balance_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Balance__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Balance class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Balance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001I\000\002F\000\003T\000\004H\000\005D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Balance_CreditDebitIndicator_RawValue(Balance *message) {
  GPBDescriptor *descriptor = [Balance descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Balance_FieldNumber_CreditDebitIndicator];
  return GPBGetMessageInt32Field(message, field);
}

void SetBalance_CreditDebitIndicator_RawValue(Balance *message, int32_t value) {
  GPBDescriptor *descriptor = [Balance descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Balance_FieldNumber_CreditDebitIndicator];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Balance_Type_RawValue(Balance *message) {
  GPBDescriptor *descriptor = [Balance descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Balance_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBalance_Type_RawValue(Balance *message, int32_t value) {
  GPBDescriptor *descriptor = [Balance descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Balance_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Balance_BalanceType

GPBEnumDescriptor *Balance_BalanceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000ClosingAvailable\000ClosingBooked\000E"
        "xpected\000ForwardAvailable\000Information\000Int"
        "erimAvailable\000InterimBooked\000OpeningAvail"
        "able\000OpeningBooked\000PreviouslyClosedBooke"
        "d\000";
    static const int32_t values[] = {
        Balance_BalanceType_Invalid,
        Balance_BalanceType_ClosingAvailable,
        Balance_BalanceType_ClosingBooked,
        Balance_BalanceType_Expected,
        Balance_BalanceType_ForwardAvailable,
        Balance_BalanceType_Information,
        Balance_BalanceType_InterimAvailable,
        Balance_BalanceType_InterimBooked,
        Balance_BalanceType_OpeningAvailable,
        Balance_BalanceType_OpeningBooked,
        Balance_BalanceType_PreviouslyClosedBooked,
    };
    static const char *extraTextFormatInfo = "\013\000\007\000\001\020\000\002\r\000\003\010\000\004\020\000\005\013\000\006\020\000\007\r\000\010\020\000\t\r\000\n\026\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Balance_BalanceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Balance_BalanceType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Balance_BalanceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Balance_BalanceType_Invalid:
    case Balance_BalanceType_ClosingAvailable:
    case Balance_BalanceType_ClosingBooked:
    case Balance_BalanceType_Expected:
    case Balance_BalanceType_ForwardAvailable:
    case Balance_BalanceType_Information:
    case Balance_BalanceType_InterimAvailable:
    case Balance_BalanceType_InterimBooked:
    case Balance_BalanceType_OpeningAvailable:
    case Balance_BalanceType_OpeningBooked:
    case Balance_BalanceType_PreviouslyClosedBooked:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BalanceData

@implementation BalanceData

@dynamic balanceArray, balanceArray_Count;

typedef struct BalanceData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *balanceArray;
} BalanceData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balanceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Balance),
        .number = BalanceData_FieldNumber_BalanceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BalanceData__storage_, balanceArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BalanceData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BalanceData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Balance\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic accountId;
@dynamic hasAmount, amount;
@dynamic hasBalance, balance;
@dynamic bookingDateTime;
@dynamic creditDebitIndicator;
@dynamic status;
@dynamic transactionId;
@dynamic transactionInformation;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  CreditDebit creditDebitIndicator;
  Transaction_TransactionStatus status;
  NSString *accountId;
  InstructedAmount *amount;
  Balance *balance;
  NSString *bookingDateTime;
  NSString *transactionId;
  NSString *transactionInformation;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = GPBStringifySymbol(InstructedAmount),
        .number = Transaction_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = GPBStringifySymbol(Balance),
        .number = Transaction_FieldNumber_Balance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bookingDateTime",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BookingDateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, bookingDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creditDebitIndicator",
        .dataTypeSpecific.enumDescFunc = CreditDebit_EnumDescriptor,
        .number = Transaction_FieldNumber_CreditDebitIndicator,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, creditDebitIndicator),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Transaction_TransactionStatus_EnumDescriptor,
        .number = Transaction_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transactionId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TransactionId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, transactionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionInformation",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TransactionInformation,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, transactionInformation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001I\000\002F\000\003G\000\004O\000\005T\000\006F\000\007M\000\010V\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_CreditDebitIndicator_RawValue(Transaction *message) {
  GPBDescriptor *descriptor = [Transaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_FieldNumber_CreditDebitIndicator];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_CreditDebitIndicator_RawValue(Transaction *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_FieldNumber_CreditDebitIndicator];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Transaction_Status_RawValue(Transaction *message) {
  GPBDescriptor *descriptor = [Transaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Status_RawValue(Transaction *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_TransactionStatus

GPBEnumDescriptor *Transaction_TransactionStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Booked\000Pending\000";
    static const int32_t values[] = {
        Transaction_TransactionStatus_Invalid,
        Transaction_TransactionStatus_Booked,
        Transaction_TransactionStatus_Pending,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\001\006\000\002\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_TransactionStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_TransactionStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_TransactionStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_TransactionStatus_Invalid:
    case Transaction_TransactionStatus_Booked:
    case Transaction_TransactionStatus_Pending:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransactionData

@implementation TransactionData

@dynamic transactionArray, transactionArray_Count;

typedef struct TransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionArray;
} TransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionData_FieldNumber_TransactionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionData__storage_, transactionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Transaction\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRequestsRequest

@implementation AccountRequestsRequest

@dynamic hasData_p, data_p;
@dynamic hasRisk, risk;

typedef struct AccountRequestsRequest__storage_ {
  uint32_t _has_storage_[1];
  AccountRequestSetup *data_p;
  Risk *risk;
} AccountRequestsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountRequestSetup),
        .number = AccountRequestsRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRequestsRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "risk",
        .dataTypeSpecific.className = GPBStringifySymbol(Risk),
        .number = AccountRequestsRequest_FieldNumber_Risk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountRequestsRequest__storage_, risk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRequestsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRequestsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000Data\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRequestsResponse

@implementation AccountRequestsResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;
@dynamic hasRisk, risk;

typedef struct AccountRequestsResponse__storage_ {
  uint32_t _has_storage_[1];
  AccountRequestData *data_p;
  Links *links;
  Meta *meta;
  Risk *risk;
} AccountRequestsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountRequestData),
        .number = AccountRequestsResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRequestsResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = AccountRequestsResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountRequestsResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Meta),
        .number = AccountRequestsResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountRequestsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "risk",
        .dataTypeSpecific.className = GPBStringifySymbol(Risk),
        .number = AccountRequestsResponse_FieldNumber_Risk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountRequestsResponse__storage_, risk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRequestsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRequestsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000Data\000\002E\000\003D\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountsRequest

@implementation AccountsRequest


typedef struct AccountsRequest__storage_ {
  uint32_t _has_storage_[1];
} AccountsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AccountsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountsResponse

@implementation AccountsResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct AccountsResponse__storage_ {
  uint32_t _has_storage_[1];
  AccountData *data_p;
  Links *links;
  MetaData *meta;
} AccountsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountData),
        .number = AccountsResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountsResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = AccountsResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountsResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaData),
        .number = AccountsResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRequest

@implementation AccountRequest

@dynamic accountId;

typedef struct AccountRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
} AccountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AccountRequest_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRequest__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountResponse

@implementation AccountResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct AccountResponse__storage_ {
  uint32_t _has_storage_[1];
  AccountData *data_p;
  Links *links;
  MetaData *meta;
} AccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountData),
        .number = AccountResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = AccountResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaData),
        .number = AccountResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAccountRequestsRequest

@implementation DeleteAccountRequestsRequest

@dynamic accountRequestId;

typedef struct DeleteAccountRequestsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountRequestId;
} DeleteAccountRequestsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountRequestId",
        .dataTypeSpecific.className = NULL,
        .number = DeleteAccountRequestsRequest_FieldNumber_AccountRequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeleteAccountRequestsRequest__storage_, accountRequestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAccountRequestsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteAccountRequestsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001P\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAccountRequestsResponse

@implementation DeleteAccountRequestsResponse


typedef struct DeleteAccountRequestsResponse__storage_ {
  uint32_t _has_storage_[1];
} DeleteAccountRequestsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAccountRequestsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteAccountRequestsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountBalancesRequest

@implementation AccountBalancesRequest

@dynamic accountId;

typedef struct AccountBalancesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
} AccountBalancesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AccountBalancesRequest_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountBalancesRequest__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountBalancesRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountBalancesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountBalancesResponse

@implementation AccountBalancesResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct AccountBalancesResponse__storage_ {
  uint32_t _has_storage_[1];
  BalanceData *data_p;
  Links *links;
  Meta *meta;
} AccountBalancesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(BalanceData),
        .number = AccountBalancesResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountBalancesResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = AccountBalancesResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountBalancesResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Meta),
        .number = AccountBalancesResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountBalancesResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountBalancesResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountBalancesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountTransactionsRequest

@implementation AccountTransactionsRequest

@dynamic accountId;
@dynamic page;

typedef struct AccountTransactionsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *accountId;
} AccountTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AccountTransactionsRequest_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountTransactionsRequest__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = AccountTransactionsRequest_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountTransactionsRequest__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountTransactionsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountTransactionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountTransactionsResponse

@implementation AccountTransactionsResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct AccountTransactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  TransactionData *data_p;
  Links *links;
  Meta *meta;
} AccountTransactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionData),
        .number = AccountTransactionsResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountTransactionsResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = AccountTransactionsResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountTransactionsResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Meta),
        .number = AccountTransactionsResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountTransactionsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountTransactionsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountTransactionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreditorAccount

@implementation CreditorAccount

@dynamic identification;
@dynamic name;
@dynamic schemeName;
@dynamic secondaryIdentification;

typedef struct CreditorAccount__storage_ {
  uint32_t _has_storage_[1];
  AccountSchemeName schemeName;
  NSString *identification;
  NSString *name;
  NSString *secondaryIdentification;
} CreditorAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = CreditorAccount_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreditorAccount__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = CreditorAccount_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreditorAccount__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = AccountSchemeName_EnumDescriptor,
        .number = CreditorAccount_FieldNumber_SchemeName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreditorAccount__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secondaryIdentification",
        .dataTypeSpecific.className = NULL,
        .number = CreditorAccount_FieldNumber_SecondaryIdentification,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CreditorAccount__storage_, secondaryIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreditorAccount class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreditorAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001N\000\002D\000\003J\000\004W\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CreditorAccount_SchemeName_RawValue(CreditorAccount *message) {
  GPBDescriptor *descriptor = [CreditorAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CreditorAccount_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetCreditorAccount_SchemeName_RawValue(CreditorAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [CreditorAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CreditorAccount_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CreditorAgent

@implementation CreditorAgent

@dynamic identification;
@dynamic schemeName;

typedef struct CreditorAgent__storage_ {
  uint32_t _has_storage_[1];
  PaymentAgentSchemeName schemeName;
  NSString *identification;
} CreditorAgent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = CreditorAgent_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreditorAgent__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = PaymentAgentSchemeName_EnumDescriptor,
        .number = CreditorAgent_FieldNumber_SchemeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreditorAgent__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreditorAgent class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreditorAgent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001N\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CreditorAgent_SchemeName_RawValue(CreditorAgent *message) {
  GPBDescriptor *descriptor = [CreditorAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CreditorAgent_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetCreditorAgent_SchemeName_RawValue(CreditorAgent *message, int32_t value) {
  GPBDescriptor *descriptor = [CreditorAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CreditorAgent_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DebtorAccount

@implementation DebtorAccount

@dynamic identification;
@dynamic name;
@dynamic schemeName;
@dynamic secondaryIdentification;

typedef struct DebtorAccount__storage_ {
  uint32_t _has_storage_[1];
  AccountSchemeName schemeName;
  NSString *identification;
  NSString *name;
  NSString *secondaryIdentification;
} DebtorAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = DebtorAccount_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DebtorAccount__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = DebtorAccount_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DebtorAccount__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = AccountSchemeName_EnumDescriptor,
        .number = DebtorAccount_FieldNumber_SchemeName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DebtorAccount__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secondaryIdentification",
        .dataTypeSpecific.className = NULL,
        .number = DebtorAccount_FieldNumber_SecondaryIdentification,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DebtorAccount__storage_, secondaryIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebtorAccount class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebtorAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001N\000\002D\000\003J\000\004W\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DebtorAccount_SchemeName_RawValue(DebtorAccount *message) {
  GPBDescriptor *descriptor = [DebtorAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DebtorAccount_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetDebtorAccount_SchemeName_RawValue(DebtorAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [DebtorAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DebtorAccount_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DebtorAgent

@implementation DebtorAgent

@dynamic identification;
@dynamic schemeName;

typedef struct DebtorAgent__storage_ {
  uint32_t _has_storage_[1];
  PaymentAgentSchemeName schemeName;
  NSString *identification;
} DebtorAgent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.className = NULL,
        .number = DebtorAgent_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DebtorAgent__storage_, identification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schemeName",
        .dataTypeSpecific.enumDescFunc = PaymentAgentSchemeName_EnumDescriptor,
        .number = DebtorAgent_FieldNumber_SchemeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DebtorAgent__storage_, schemeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebtorAgent class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebtorAgent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001N\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DebtorAgent_SchemeName_RawValue(DebtorAgent *message) {
  GPBDescriptor *descriptor = [DebtorAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DebtorAgent_FieldNumber_SchemeName];
  return GPBGetMessageInt32Field(message, field);
}

void SetDebtorAgent_SchemeName_RawValue(DebtorAgent *message, int32_t value) {
  GPBDescriptor *descriptor = [DebtorAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DebtorAgent_FieldNumber_SchemeName];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - InstructedAmount

@implementation InstructedAmount

@dynamic amount;
@dynamic currency;

typedef struct InstructedAmount__storage_ {
  uint32_t _has_storage_[1];
  NSString *amount;
  NSString *currency;
} InstructedAmount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = InstructedAmount_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InstructedAmount__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = InstructedAmount_FieldNumber_Currency,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InstructedAmount__storage_, currency),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InstructedAmount class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InstructedAmount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemittanceInformation

@implementation RemittanceInformation

@dynamic reference;
@dynamic unstructured;

typedef struct RemittanceInformation__storage_ {
  uint32_t _has_storage_[1];
  NSString *reference;
  NSString *unstructured;
} RemittanceInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reference",
        .dataTypeSpecific.className = NULL,
        .number = RemittanceInformation_FieldNumber_Reference,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemittanceInformation__storage_, reference),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unstructured",
        .dataTypeSpecific.className = NULL,
        .number = RemittanceInformation_FieldNumber_Unstructured,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemittanceInformation__storage_, unstructured),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemittanceInformation class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemittanceInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001I\000\002L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Initiation

@implementation Initiation

@dynamic hasCreditorAccount, creditorAccount;
@dynamic hasCreditorAgent, creditorAgent;
@dynamic hasDebtorAccount, debtorAccount;
@dynamic hasDebtorAgent, debtorAgent;
@dynamic endToEndIdentification;
@dynamic hasInstructedAmount, instructedAmount;
@dynamic instructionIdentification;
@dynamic hasRemittanceInformation, remittanceInformation;

typedef struct Initiation__storage_ {
  uint32_t _has_storage_[1];
  CreditorAccount *creditorAccount;
  CreditorAgent *creditorAgent;
  DebtorAccount *debtorAccount;
  DebtorAgent *debtorAgent;
  NSString *endToEndIdentification;
  InstructedAmount *instructedAmount;
  NSString *instructionIdentification;
  RemittanceInformation *remittanceInformation;
} Initiation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "creditorAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(CreditorAccount),
        .number = Initiation_FieldNumber_CreditorAccount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Initiation__storage_, creditorAccount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "creditorAgent",
        .dataTypeSpecific.className = GPBStringifySymbol(CreditorAgent),
        .number = Initiation_FieldNumber_CreditorAgent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Initiation__storage_, creditorAgent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debtorAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(DebtorAccount),
        .number = Initiation_FieldNumber_DebtorAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Initiation__storage_, debtorAccount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debtorAgent",
        .dataTypeSpecific.className = GPBStringifySymbol(DebtorAgent),
        .number = Initiation_FieldNumber_DebtorAgent,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Initiation__storage_, debtorAgent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endToEndIdentification",
        .dataTypeSpecific.className = NULL,
        .number = Initiation_FieldNumber_EndToEndIdentification,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Initiation__storage_, endToEndIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "instructedAmount",
        .dataTypeSpecific.className = GPBStringifySymbol(InstructedAmount),
        .number = Initiation_FieldNumber_InstructedAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Initiation__storage_, instructedAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "instructionIdentification",
        .dataTypeSpecific.className = NULL,
        .number = Initiation_FieldNumber_InstructionIdentification,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Initiation__storage_, instructionIdentification),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remittanceInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(RemittanceInformation),
        .number = Initiation_FieldNumber_RemittanceInformation,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Initiation__storage_, remittanceInformation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Initiation class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Initiation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001O\000\002M\000\003M\000\004K\000\005V\000\006P\000\007Y\000\010U\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentSetup

@implementation PaymentSetup

@dynamic hasInitiation, initiation;

typedef struct PaymentSetup__storage_ {
  uint32_t _has_storage_[1];
  Initiation *initiation;
} PaymentSetup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "initiation",
        .dataTypeSpecific.className = GPBStringifySymbol(Initiation),
        .number = PaymentSetup_FieldNumber_Initiation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSetup__storage_, initiation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSetup class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSetup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentData

@implementation PaymentData

@dynamic creationDateTime;
@dynamic hasInitiation, initiation;
@dynamic paymentId;
@dynamic status;

typedef struct PaymentData__storage_ {
  uint32_t _has_storage_[1];
  PaymentData_PaymentSetupStatus status;
  NSString *creationDateTime;
  Initiation *initiation;
  NSString *paymentId;
} PaymentData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "creationDateTime",
        .dataTypeSpecific.className = NULL,
        .number = PaymentData_FieldNumber_CreationDateTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentData__storage_, creationDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initiation",
        .dataTypeSpecific.className = GPBStringifySymbol(Initiation),
        .number = PaymentData_FieldNumber_Initiation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentData__storage_, initiation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paymentId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentData_FieldNumber_PaymentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentData__storage_, paymentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PaymentData_PaymentSetupStatus_EnumDescriptor,
        .number = PaymentData_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentData__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001P\000\002J\000\003I\000\004F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PaymentData_Status_RawValue(PaymentData *message) {
  GPBDescriptor *descriptor = [PaymentData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PaymentData_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPaymentData_Status_RawValue(PaymentData *message, int32_t value) {
  GPBDescriptor *descriptor = [PaymentData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PaymentData_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PaymentData_PaymentSetupStatus

GPBEnumDescriptor *PaymentData_PaymentSetupStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000AcceptedCustomerProfile\000Accepted"
        "TechnicalValidation\000Pending\000Rejected\000";
    static const int32_t values[] = {
        PaymentData_PaymentSetupStatus_Invalid,
        PaymentData_PaymentSetupStatus_AcceptedCustomerProfile,
        PaymentData_PaymentSetupStatus_AcceptedTechnicalValidation,
        PaymentData_PaymentSetupStatus_Pending,
        PaymentData_PaymentSetupStatus_Rejected,
    };
    static const char *extraTextFormatInfo = "\005\000\007\000\001\027\000\002\033\000\003\007\000\004\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PaymentData_PaymentSetupStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PaymentData_PaymentSetupStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PaymentData_PaymentSetupStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PaymentData_PaymentSetupStatus_Invalid:
    case PaymentData_PaymentSetupStatus_AcceptedCustomerProfile:
    case PaymentData_PaymentSetupStatus_AcceptedTechnicalValidation:
    case PaymentData_PaymentSetupStatus_Pending:
    case PaymentData_PaymentSetupStatus_Rejected:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PaymentSubmission

@implementation PaymentSubmission

@dynamic hasInitiation, initiation;
@dynamic paymentId;

typedef struct PaymentSubmission__storage_ {
  uint32_t _has_storage_[1];
  Initiation *initiation;
  NSString *paymentId;
} PaymentSubmission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "initiation",
        .dataTypeSpecific.className = GPBStringifySymbol(Initiation),
        .number = PaymentSubmission_FieldNumber_Initiation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSubmission__storage_, initiation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paymentId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSubmission_FieldNumber_PaymentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentSubmission__storage_, paymentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSubmission class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSubmission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentSubmissionData

@implementation PaymentSubmissionData

@dynamic paymentId;
@dynamic paymentSubmissionId;
@dynamic creationDateTime;
@dynamic status;

typedef struct PaymentSubmissionData__storage_ {
  uint32_t _has_storage_[1];
  PaymentSubmissionData_PaymentSubmissionStatus status;
  NSString *paymentId;
  NSString *paymentSubmissionId;
  NSString *creationDateTime;
} PaymentSubmissionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSubmissionData_FieldNumber_PaymentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSubmissionData__storage_, paymentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentSubmissionId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSubmissionData_FieldNumber_PaymentSubmissionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentSubmissionData__storage_, paymentSubmissionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creationDateTime",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSubmissionData_FieldNumber_CreationDateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentSubmissionData__storage_, creationDateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PaymentSubmissionData_PaymentSubmissionStatus_EnumDescriptor,
        .number = PaymentSubmissionData_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentSubmissionData__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSubmissionData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSubmissionData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001I\000\002S\000\003P\000\004F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PaymentSubmissionData_Status_RawValue(PaymentSubmissionData *message) {
  GPBDescriptor *descriptor = [PaymentSubmissionData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PaymentSubmissionData_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPaymentSubmissionData_Status_RawValue(PaymentSubmissionData *message, int32_t value) {
  GPBDescriptor *descriptor = [PaymentSubmissionData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PaymentSubmissionData_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PaymentSubmissionData_PaymentSubmissionStatus

GPBEnumDescriptor *PaymentSubmissionData_PaymentSubmissionStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000AcceptedSettlementCompleted\000Acce"
        "ptedSettlementInProgress\000Pending\000Rejecte"
        "d\000";
    static const int32_t values[] = {
        PaymentSubmissionData_PaymentSubmissionStatus_Invalid,
        PaymentSubmissionData_PaymentSubmissionStatus_AcceptedSettlementCompleted,
        PaymentSubmissionData_PaymentSubmissionStatus_AcceptedSettlementInProgress,
        PaymentSubmissionData_PaymentSubmissionStatus_Pending,
        PaymentSubmissionData_PaymentSubmissionStatus_Rejected,
    };
    static const char *extraTextFormatInfo = "\005\000\007\000\001\033\000\002\034\000\003\007\000\004\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PaymentSubmissionData_PaymentSubmissionStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PaymentSubmissionData_PaymentSubmissionStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PaymentSubmissionData_PaymentSubmissionStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PaymentSubmissionData_PaymentSubmissionStatus_Invalid:
    case PaymentSubmissionData_PaymentSubmissionStatus_AcceptedSettlementCompleted:
    case PaymentSubmissionData_PaymentSubmissionStatus_AcceptedSettlementInProgress:
    case PaymentSubmissionData_PaymentSubmissionStatus_Pending:
    case PaymentSubmissionData_PaymentSubmissionStatus_Rejected:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PaymentsRequest

@implementation PaymentsRequest

@dynamic hasData_p, data_p;
@dynamic hasRisk, risk;

typedef struct PaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
  PaymentSetup *data_p;
  Risk *risk;
} PaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PaymentSetup),
        .number = PaymentsRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentsRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "risk",
        .dataTypeSpecific.className = GPBStringifySymbol(Risk),
        .number = PaymentsRequest_FieldNumber_Risk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentsRequest__storage_, risk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000Data\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentsResponse

@implementation PaymentsResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;
@dynamic hasRisk, risk;

typedef struct PaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
  PaymentData *data_p;
  Links *links;
  Meta *meta;
  Risk *risk;
} PaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PaymentData),
        .number = PaymentsResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentsResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = PaymentsResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentsResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Meta),
        .number = PaymentsResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "risk",
        .dataTypeSpecific.className = GPBStringifySymbol(Risk),
        .number = PaymentsResponse_FieldNumber_Risk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentsResponse__storage_, risk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000Data\000\002E\000\003D\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentSubmissionsRequest

@implementation PaymentSubmissionsRequest

@dynamic hasData_p, data_p;
@dynamic hasRisk, risk;

typedef struct PaymentSubmissionsRequest__storage_ {
  uint32_t _has_storage_[1];
  PaymentSubmission *data_p;
  Risk *risk;
} PaymentSubmissionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PaymentSubmission),
        .number = PaymentSubmissionsRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSubmissionsRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "risk",
        .dataTypeSpecific.className = GPBStringifySymbol(Risk),
        .number = PaymentSubmissionsRequest_FieldNumber_Risk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentSubmissionsRequest__storage_, risk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSubmissionsRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSubmissionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000Data\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentSubmissionsResponse

@implementation PaymentSubmissionsResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct PaymentSubmissionsResponse__storage_ {
  uint32_t _has_storage_[1];
  PaymentSubmissionData *data_p;
  Links *links;
  Meta *meta;
} PaymentSubmissionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PaymentSubmissionData),
        .number = PaymentSubmissionsResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSubmissionsResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = PaymentSubmissionsResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentSubmissionsResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Meta),
        .number = PaymentSubmissionsResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentSubmissionsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSubmissionsResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSubmissionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Address

@implementation Address

@dynamic addressType;
@dynamic addressLineArray, addressLineArray_Count;
@dynamic streetName;
@dynamic buildingNumber;
@dynamic postCode;
@dynamic townName;
@dynamic countrySubDivision;
@dynamic country;

typedef struct Address__storage_ {
  uint32_t _has_storage_[1];
  Address_AddressTypeEnum addressType;
  NSMutableArray *addressLineArray;
  NSString *streetName;
  NSString *buildingNumber;
  NSString *postCode;
  NSString *townName;
  NSString *countrySubDivision;
  NSString *country;
} Address__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressType",
        .dataTypeSpecific.enumDescFunc = Address_AddressTypeEnum_EnumDescriptor,
        .number = Address_FieldNumber_AddressType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Address__storage_, addressType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "addressLineArray",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_AddressLineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Address__storage_, addressLineArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streetName",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_StreetName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Address__storage_, streetName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildingNumber",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_BuildingNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Address__storage_, buildingNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postCode",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_PostCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Address__storage_, postCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "townName",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_TownName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Address__storage_, townName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "countrySubDivision",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_CountrySubDivision,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Address__storage_, countrySubDivision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = Address_FieldNumber_Country,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Address__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Address class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Address__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001K\000\002\000AddressLine\000\003J\000\004N\000\005H\000\006H\000\007R\000\010G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Address_AddressType_RawValue(Address *message) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_AddressType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAddress_AddressType_RawValue(Address *message, int32_t value) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_AddressType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Address_AddressTypeEnum

GPBEnumDescriptor *Address_AddressTypeEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Business\000Correspondence\000Delivery"
        "To\000MailTo\000Pobox\000Postal\000Residential\000State"
        "ment\000";
    static const int32_t values[] = {
        Address_AddressTypeEnum_Invalid,
        Address_AddressTypeEnum_Business,
        Address_AddressTypeEnum_Correspondence,
        Address_AddressTypeEnum_DeliveryTo,
        Address_AddressTypeEnum_MailTo,
        Address_AddressTypeEnum_Pobox,
        Address_AddressTypeEnum_Postal,
        Address_AddressTypeEnum_Residential,
        Address_AddressTypeEnum_Statement,
    };
    static const char *extraTextFormatInfo = "\t\000\007\000\001\010\000\002\016\000\003\n\000\004\006\000\005c\002\000\006\006\000\007\013\000\010\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Address_AddressTypeEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Address_AddressTypeEnum_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Address_AddressTypeEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case Address_AddressTypeEnum_Invalid:
    case Address_AddressTypeEnum_Business:
    case Address_AddressTypeEnum_Correspondence:
    case Address_AddressTypeEnum_DeliveryTo:
    case Address_AddressTypeEnum_MailTo:
    case Address_AddressTypeEnum_Pobox:
    case Address_AddressTypeEnum_Postal:
    case Address_AddressTypeEnum_Residential:
    case Address_AddressTypeEnum_Statement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Party

@implementation Party

@dynamic partyId;
@dynamic partyNumber;
@dynamic partyType;
@dynamic name;
@dynamic emailAddress;
@dynamic phone;
@dynamic mobile;
@dynamic addressArray, addressArray_Count;

typedef struct Party__storage_ {
  uint32_t _has_storage_[1];
  Party_PartyTypeEnum partyType;
  NSString *partyId;
  NSString *partyNumber;
  NSString *name;
  NSString *emailAddress;
  NSString *phone;
  NSString *mobile;
  NSMutableArray *addressArray;
} Party__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "partyId",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_PartyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Party__storage_, partyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "partyNumber",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_PartyNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Party__storage_, partyNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "partyType",
        .dataTypeSpecific.enumDescFunc = Party_PartyTypeEnum_EnumDescriptor,
        .number = Party_FieldNumber_PartyType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Party__storage_, partyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Party__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_EmailAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Party__storage_, emailAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_Phone,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Party__storage_, phone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = Party_FieldNumber_Mobile,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Party__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Address),
        .number = Party_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Party__storage_, addressArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Party class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Party__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001G\000\002K\000\003I\000\004D\000\005L\000\006E\000\007F\000\010\000Address\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Party_PartyType_RawValue(Party *message) {
  GPBDescriptor *descriptor = [Party descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Party_FieldNumber_PartyType];
  return GPBGetMessageInt32Field(message, field);
}

void SetParty_PartyType_RawValue(Party *message, int32_t value) {
  GPBDescriptor *descriptor = [Party descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Party_FieldNumber_PartyType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Party_PartyTypeEnum

GPBEnumDescriptor *Party_PartyTypeEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Delegate\000Joint\000Sole\000";
    static const int32_t values[] = {
        Party_PartyTypeEnum_Invalid,
        Party_PartyTypeEnum_Delegate,
        Party_PartyTypeEnum_Joint,
        Party_PartyTypeEnum_Sole,
    };
    static const char *extraTextFormatInfo = "\004\000\007\000\001\010\000\002\005\000\003\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Party_PartyTypeEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Party_PartyTypeEnum_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Party_PartyTypeEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case Party_PartyTypeEnum_Invalid:
    case Party_PartyTypeEnum_Delegate:
    case Party_PartyTypeEnum_Joint:
    case Party_PartyTypeEnum_Sole:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PartyData

@implementation PartyData

@dynamic hasParty, party;

typedef struct PartyData__storage_ {
  uint32_t _has_storage_[1];
  Party *party;
} PartyData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "party",
        .dataTypeSpecific.className = GPBStringifySymbol(Party),
        .number = PartyData_FieldNumber_Party,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PartyData__storage_, party),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PartyData class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PartyData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PartyRequest

@implementation PartyRequest

@dynamic accountId;

typedef struct PartyRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
} PartyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = PartyRequest_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PartyRequest__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PartyRequest class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PartyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PartyResponse

@implementation PartyResponse

@dynamic hasData_p, data_p;
@dynamic hasLinks, links;
@dynamic hasMeta, meta;

typedef struct PartyResponse__storage_ {
  uint32_t _has_storage_[1];
  PartyData *data_p;
  Links *links;
  MetaData *meta;
} PartyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PartyData),
        .number = PartyResponse_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PartyResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Links),
        .number = PartyResponse_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PartyResponse__storage_, links),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaData),
        .number = PartyResponse_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PartyResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PartyResponse class]
                                     rootClass:[Cma9Root class]
                                          file:Cma9Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PartyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000Data\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
