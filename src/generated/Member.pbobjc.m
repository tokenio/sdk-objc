// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: member.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Member.pbobjc.h"
#import "Address.pbobjc.h"
#import "Alias.pbobjc.h"
#import "Security.pbobjc.h"
#import "extensions/Field.pbobjc.h"
#import "extensions/Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - MemberRoot

@implementation MemberRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[MessageRoot extensionRegistry]];
    [registry addExtensions:[FieldRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MemberRoot_FileDescriptor

static GPBFileDescriptor *MemberRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"io.token.proto.common.member"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ProfilePictureSize

GPBEnumDescriptor *ProfilePictureSize_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Original\000Small\000Medium\000Large\000";
    static const int32_t values[] = {
        ProfilePictureSize_Invalid,
        ProfilePictureSize_Original,
        ProfilePictureSize_Small,
        ProfilePictureSize_Medium,
        ProfilePictureSize_Large,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProfilePictureSize)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProfilePictureSize_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProfilePictureSize_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProfilePictureSize_Invalid:
    case ProfilePictureSize_Original:
    case ProfilePictureSize_Small:
    case ProfilePictureSize_Medium:
    case ProfilePictureSize_Large:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CreateMemberType

GPBEnumDescriptor *CreateMemberType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidMemberType\000Personal\000Business\000Tran"
        "sient\000";
    static const int32_t values[] = {
        CreateMemberType_InvalidMemberType,
        CreateMemberType_Personal,
        CreateMemberType_Business,
        CreateMemberType_Transient,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CreateMemberType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CreateMemberType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CreateMemberType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CreateMemberType_InvalidMemberType:
    case CreateMemberType_Personal:
    case CreateMemberType_Business:
    case CreateMemberType_Transient:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MemberAddKeyOperation

@implementation MemberAddKeyOperation

@dynamic hasKey, key;

typedef struct MemberAddKeyOperation__storage_ {
  uint32_t _has_storage_[1];
  Key *key;
} MemberAddKeyOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = MemberAddKeyOperation_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberAddKeyOperation__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberAddKeyOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberAddKeyOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberRemoveKeyOperation

@implementation MemberRemoveKeyOperation

@dynamic keyId;

typedef struct MemberRemoveKeyOperation__storage_ {
  uint32_t _has_storage_[1];
  NSString *keyId;
} MemberRemoveKeyOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyId",
        .dataTypeSpecific.className = NULL,
        .number = MemberRemoveKeyOperation_FieldNumber_KeyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberRemoveKeyOperation__storage_, keyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberRemoveKeyOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberRemoveKeyOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberAliasOperation

@implementation MemberAliasOperation

@dynamic aliasHash;
@dynamic realm;

typedef struct MemberAliasOperation__storage_ {
  uint32_t _has_storage_[1];
  NSString *aliasHash;
  NSString *realm;
} MemberAliasOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aliasHash",
        .dataTypeSpecific.className = NULL,
        .number = MemberAliasOperation_FieldNumber_AliasHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberAliasOperation__storage_, aliasHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realm",
        .dataTypeSpecific.className = NULL,
        .number = MemberAliasOperation_FieldNumber_Realm,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberAliasOperation__storage_, realm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberAliasOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberAliasOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberRecoveryRulesOperation

@implementation MemberRecoveryRulesOperation

@dynamic hasRecoveryRule, recoveryRule;

typedef struct MemberRecoveryRulesOperation__storage_ {
  uint32_t _has_storage_[1];
  RecoveryRule *recoveryRule;
} MemberRecoveryRulesOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recoveryRule",
        .dataTypeSpecific.className = GPBStringifySymbol(RecoveryRule),
        .number = MemberRecoveryRulesOperation_FieldNumber_RecoveryRule,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberRecoveryRulesOperation__storage_, recoveryRule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberRecoveryRulesOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberRecoveryRulesOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberRecoveryOperation

@implementation MemberRecoveryOperation

@dynamic hasAuthorization, authorization;
@dynamic hasAgentSignature, agentSignature;

typedef struct MemberRecoveryOperation__storage_ {
  uint32_t _has_storage_[1];
  MemberRecoveryOperation_Authorization *authorization;
  Signature *agentSignature;
} MemberRecoveryOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authorization",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberRecoveryOperation_Authorization),
        .number = MemberRecoveryOperation_FieldNumber_Authorization,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberRecoveryOperation__storage_, authorization),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "agentSignature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = MemberRecoveryOperation_FieldNumber_AgentSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberRecoveryOperation__storage_, agentSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberRecoveryOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberRecoveryOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberRecoveryOperation_Authorization

@implementation MemberRecoveryOperation_Authorization

@dynamic memberId;
@dynamic prevHash;
@dynamic hasMemberKey, memberKey;

typedef struct MemberRecoveryOperation_Authorization__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
  NSString *prevHash;
  Key *memberKey;
} MemberRecoveryOperation_Authorization__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.className = NULL,
        .number = MemberRecoveryOperation_Authorization_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberRecoveryOperation_Authorization__storage_, memberId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prevHash",
        .dataTypeSpecific.className = NULL,
        .number = MemberRecoveryOperation_Authorization_FieldNumber_PrevHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberRecoveryOperation_Authorization__storage_, prevHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberKey",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = MemberRecoveryOperation_Authorization_FieldNumber_MemberKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MemberRecoveryOperation_Authorization__storage_, memberKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberRecoveryOperation_Authorization class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberRecoveryOperation_Authorization__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(MemberRecoveryOperation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberDeleteOperation

@implementation MemberDeleteOperation


typedef struct MemberDeleteOperation__storage_ {
  uint32_t _has_storage_[1];
} MemberDeleteOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberDeleteOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(MemberDeleteOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberPartnerOperation

@implementation MemberPartnerOperation


typedef struct MemberPartnerOperation__storage_ {
  uint32_t _has_storage_[1];
} MemberPartnerOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberPartnerOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(MemberPartnerOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberOperation

@implementation MemberOperation

@dynamic operationOneOfCase;
@dynamic addKey;
@dynamic removeKey;
@dynamic removeAlias;
@dynamic addAlias;
@dynamic verifyAlias;
@dynamic recoveryRules;
@dynamic recover;
@dynamic delete_p;
@dynamic verifyPartner;
@dynamic unverifyPartner;

typedef struct MemberOperation__storage_ {
  uint32_t _has_storage_[2];
  MemberAddKeyOperation *addKey;
  MemberRemoveKeyOperation *removeKey;
  MemberAliasOperation *removeAlias;
  MemberAliasOperation *addAlias;
  MemberAliasOperation *verifyAlias;
  MemberRecoveryRulesOperation *recoveryRules;
  MemberRecoveryOperation *recover;
  MemberDeleteOperation *delete_p;
  MemberPartnerOperation *verifyPartner;
  MemberPartnerOperation *unverifyPartner;
} MemberOperation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addKey",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberAddKeyOperation),
        .number = MemberOperation_FieldNumber_AddKey,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, addKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeKey",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberRemoveKeyOperation),
        .number = MemberOperation_FieldNumber_RemoveKey,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, removeKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeAlias",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberAliasOperation),
        .number = MemberOperation_FieldNumber_RemoveAlias,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, removeAlias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addAlias",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberAliasOperation),
        .number = MemberOperation_FieldNumber_AddAlias,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, addAlias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifyAlias",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberAliasOperation),
        .number = MemberOperation_FieldNumber_VerifyAlias,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, verifyAlias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recoveryRules",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberRecoveryRulesOperation),
        .number = MemberOperation_FieldNumber_RecoveryRules,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, recoveryRules),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recover",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberRecoveryOperation),
        .number = MemberOperation_FieldNumber_Recover,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, recover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberDeleteOperation),
        .number = MemberOperation_FieldNumber_Delete_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, delete_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifyPartner",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberPartnerOperation),
        .number = MemberOperation_FieldNumber_VerifyPartner,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, verifyPartner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unverifyPartner",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberPartnerOperation),
        .number = MemberOperation_FieldNumber_UnverifyPartner,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperation__storage_, unverifyPartner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberOperation class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberOperation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "operation",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MemberOperation_ClearOperationOneOfCase(MemberOperation *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - MemberUpdate

@implementation MemberUpdate

@dynamic prevHash;
@dynamic memberId;
@dynamic operationsArray, operationsArray_Count;

typedef struct MemberUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSString *prevHash;
  NSString *memberId;
  NSMutableArray *operationsArray;
} MemberUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prevHash",
        .dataTypeSpecific.className = NULL,
        .number = MemberUpdate_FieldNumber_PrevHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberUpdate__storage_, prevHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberId",
        .dataTypeSpecific.className = NULL,
        .number = MemberUpdate_FieldNumber_MemberId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberUpdate__storage_, memberId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "operationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberOperation),
        .number = MemberUpdate_FieldNumber_OperationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MemberUpdate__storage_, operationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberUpdate class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberOperationMetadata

@implementation MemberOperationMetadata

@dynamic typeOneOfCase;
@dynamic addAliasMetadata;

typedef struct MemberOperationMetadata__storage_ {
  uint32_t _has_storage_[2];
  MemberOperationMetadata_AddAliasMetadata *addAliasMetadata;
} MemberOperationMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addAliasMetadata",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberOperationMetadata_AddAliasMetadata),
        .number = MemberOperationMetadata_FieldNumber_AddAliasMetadata,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperationMetadata__storage_, addAliasMetadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberOperationMetadata class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberOperationMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "type",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MemberOperationMetadata_ClearTypeOneOfCase(MemberOperationMetadata *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - MemberOperationMetadata_AddAliasMetadata

@implementation MemberOperationMetadata_AddAliasMetadata

@dynamic aliasHash;
@dynamic hasAlias, alias;

typedef struct MemberOperationMetadata_AddAliasMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSString *aliasHash;
  Alias *alias;
} MemberOperationMetadata_AddAliasMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aliasHash",
        .dataTypeSpecific.className = NULL,
        .number = MemberOperationMetadata_AddAliasMetadata_FieldNumber_AliasHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberOperationMetadata_AddAliasMetadata__storage_, aliasHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = GPBStringifySymbol(Alias),
        .number = MemberOperationMetadata_AddAliasMetadata_FieldNumber_Alias,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberOperationMetadata_AddAliasMetadata__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberOperationMetadata_AddAliasMetadata class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberOperationMetadata_AddAliasMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(MemberOperationMetadata)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberOperationResponseMetadata

@implementation MemberOperationResponseMetadata

@dynamic typeOneOfCase;
@dynamic addAliasResponseMetadata;

typedef struct MemberOperationResponseMetadata__storage_ {
  uint32_t _has_storage_[2];
  MemberOperationResponseMetadata_AddAliasResponseMetadata *addAliasResponseMetadata;
} MemberOperationResponseMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addAliasResponseMetadata",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberOperationResponseMetadata_AddAliasResponseMetadata),
        .number = MemberOperationResponseMetadata_FieldNumber_AddAliasResponseMetadata,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MemberOperationResponseMetadata__storage_, addAliasResponseMetadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberOperationResponseMetadata class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberOperationResponseMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "type",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MemberOperationResponseMetadata_ClearTypeOneOfCase(MemberOperationResponseMetadata *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - MemberOperationResponseMetadata_AddAliasResponseMetadata

@implementation MemberOperationResponseMetadata_AddAliasResponseMetadata

@dynamic aliasHash;
@dynamic verificationId;

typedef struct MemberOperationResponseMetadata_AddAliasResponseMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSString *aliasHash;
  NSString *verificationId;
} MemberOperationResponseMetadata_AddAliasResponseMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aliasHash",
        .dataTypeSpecific.className = NULL,
        .number = MemberOperationResponseMetadata_AddAliasResponseMetadata_FieldNumber_AliasHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberOperationResponseMetadata_AddAliasResponseMetadata__storage_, aliasHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verificationId",
        .dataTypeSpecific.className = NULL,
        .number = MemberOperationResponseMetadata_AddAliasResponseMetadata_FieldNumber_VerificationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberOperationResponseMetadata_AddAliasResponseMetadata__storage_, verificationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberOperationResponseMetadata_AddAliasResponseMetadata class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberOperationResponseMetadata_AddAliasResponseMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(MemberOperationResponseMetadata)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecoveryRule

@implementation RecoveryRule

@dynamic primaryAgent;
@dynamic secondaryAgentsArray, secondaryAgentsArray_Count;

typedef struct RecoveryRule__storage_ {
  uint32_t _has_storage_[1];
  NSString *primaryAgent;
  NSMutableArray *secondaryAgentsArray;
} RecoveryRule__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "primaryAgent",
        .dataTypeSpecific.className = NULL,
        .number = RecoveryRule_FieldNumber_PrimaryAgent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecoveryRule__storage_, primaryAgent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondaryAgentsArray",
        .dataTypeSpecific.className = NULL,
        .number = RecoveryRule_FieldNumber_SecondaryAgentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RecoveryRule__storage_, secondaryAgentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecoveryRule class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecoveryRule__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Member

@implementation Member

@dynamic id_p;
@dynamic lastHash;
@dynamic aliasHashesArray, aliasHashesArray_Count;
@dynamic keysArray, keysArray_Count;
@dynamic unverifiedAliasHashesArray, unverifiedAliasHashesArray_Count;
@dynamic hasRecoveryRule, recoveryRule;
@dynamic lastRecoverySequence;
@dynamic lastOperationSequence;
@dynamic type;
@dynamic partnerId;
@dynamic isVerifiedPartner;

typedef struct Member__storage_ {
  uint32_t _has_storage_[1];
  int32_t lastRecoverySequence;
  int32_t lastOperationSequence;
  Member_MemberType type;
  NSString *id_p;
  NSString *lastHash;
  NSMutableArray *aliasHashesArray;
  NSMutableArray *keysArray;
  NSMutableArray *unverifiedAliasHashesArray;
  RecoveryRule *recoveryRule;
  NSString *partnerId;
} Member__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Member__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastHash",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_LastHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Member__storage_, lastHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aliasHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_AliasHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Member__storage_, aliasHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = Member_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Member__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unverifiedAliasHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_UnverifiedAliasHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Member__storage_, unverifiedAliasHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recoveryRule",
        .dataTypeSpecific.className = GPBStringifySymbol(RecoveryRule),
        .number = Member_FieldNumber_RecoveryRule,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Member__storage_, recoveryRule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastRecoverySequence",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_LastRecoverySequence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Member__storage_, lastRecoverySequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastOperationSequence",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_LastOperationSequence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Member__storage_, lastOperationSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Member_MemberType_EnumDescriptor,
        .number = Member_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Member__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "partnerId",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_PartnerId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Member__storage_, partnerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isVerifiedPartner",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_IsVerifiedPartner,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Member class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Member__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Member_Type_RawValue(Member *message) {
  GPBDescriptor *descriptor = [Member descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Member_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetMember_Type_RawValue(Member *message, int32_t value) {
  GPBDescriptor *descriptor = [Member descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Member_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Member_MemberType

GPBEnumDescriptor *Member_MemberType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidMemberType\000Personal\000BusinessUnver"
        "ified\000BusinessVerified\000Transient\000";
    static const int32_t values[] = {
        Member_MemberType_InvalidMemberType,
        Member_MemberType_Personal,
        Member_MemberType_BusinessUnverified,
        Member_MemberType_BusinessVerified,
        Member_MemberType_Transient,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Member_MemberType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Member_MemberType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Member_MemberType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Member_MemberType_InvalidMemberType:
    case Member_MemberType_Personal:
    case Member_MemberType_BusinessUnverified:
    case Member_MemberType_BusinessVerified:
    case Member_MemberType_Transient:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AddressRecord

@implementation AddressRecord

@dynamic id_p;
@dynamic name;
@dynamic hasAddress, address;
@dynamic hasAddressSignature, addressSignature;

typedef struct AddressRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  Address *address;
  Signature *addressSignature;
} AddressRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = AddressRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AddressRecord_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressRecord__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = GPBStringifySymbol(Address),
        .number = AddressRecord_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddressRecord__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addressSignature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = AddressRecord_FieldNumber_AddressSignature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddressRecord__storage_, addressSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressRecord class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Profile

@implementation Profile

@dynamic displayNameFirst;
@dynamic displayNameLast;
@dynamic originalPictureId;
@dynamic smallPictureId;
@dynamic mediumPictureId;
@dynamic largePictureId;

typedef struct Profile__storage_ {
  uint32_t _has_storage_[1];
  NSString *displayNameFirst;
  NSString *displayNameLast;
  NSString *originalPictureId;
  NSString *smallPictureId;
  NSString *mediumPictureId;
  NSString *largePictureId;
} Profile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "displayNameFirst",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_DisplayNameFirst,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Profile__storage_, displayNameFirst),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayNameLast",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_DisplayNameLast,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Profile__storage_, displayNameLast),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalPictureId",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_OriginalPictureId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Profile__storage_, originalPictureId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallPictureId",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_SmallPictureId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Profile__storage_, smallPictureId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediumPictureId",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_MediumPictureId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Profile__storage_, mediumPictureId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "largePictureId",
        .dataTypeSpecific.className = NULL,
        .number = Profile_FieldNumber_LargePictureId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Profile__storage_, largePictureId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Profile class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Profile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiptContact

@implementation ReceiptContact

@dynamic value;
@dynamic type;

typedef struct ReceiptContact__storage_ {
  uint32_t _has_storage_[1];
  ReceiptContact_Type type;
  NSString *value;
} ReceiptContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ReceiptContact_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiptContact__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ReceiptContact_Type_EnumDescriptor,
        .number = ReceiptContact_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceiptContact__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiptContact class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiptContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ReceiptContact_Type_RawValue(ReceiptContact *message) {
  GPBDescriptor *descriptor = [ReceiptContact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReceiptContact_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetReceiptContact_Type_RawValue(ReceiptContact *message, int32_t value) {
  GPBDescriptor *descriptor = [ReceiptContact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReceiptContact_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ReceiptContact_Type

GPBEnumDescriptor *ReceiptContact_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Email\000";
    static const int32_t values[] = {
        ReceiptContact_Type_Invalid,
        ReceiptContact_Type_Email,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReceiptContact_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReceiptContact_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReceiptContact_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReceiptContact_Type_Invalid:
    case ReceiptContact_Type_Email:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Device

@implementation Device

@dynamic name;
@dynamic hasKey, key;
@dynamic keysArray, keysArray_Count;

typedef struct Device__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  Key *key;
  NSMutableArray *keysArray;
} Device__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Device_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Device__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = Device_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Device__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = Device_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Device__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Device class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Device__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrustedBeneficiary

@implementation TrustedBeneficiary

@dynamic hasPayload, payload;
@dynamic hasSignature, signature;

typedef struct TrustedBeneficiary__storage_ {
  uint32_t _has_storage_[1];
  TrustedBeneficiary_Payload *payload;
  Signature *signature;
} TrustedBeneficiary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.className = GPBStringifySymbol(TrustedBeneficiary_Payload),
        .number = TrustedBeneficiary_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrustedBeneficiary__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = TrustedBeneficiary_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TrustedBeneficiary__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrustedBeneficiary class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrustedBeneficiary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrustedBeneficiary_Payload

@implementation TrustedBeneficiary_Payload

@dynamic memberId;
@dynamic nonce;

typedef struct TrustedBeneficiary_Payload__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
  NSString *nonce;
} TrustedBeneficiary_Payload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.className = NULL,
        .number = TrustedBeneficiary_Payload_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrustedBeneficiary_Payload__storage_, memberId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = TrustedBeneficiary_Payload_FieldNumber_Nonce,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TrustedBeneficiary_Payload__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrustedBeneficiary_Payload class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrustedBeneficiary_Payload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TrustedBeneficiary)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Customization

@implementation Customization

@dynamic customizationId;
@dynamic logoBlobId;
@dynamic colors, colors_Count;

typedef struct Customization__storage_ {
  uint32_t _has_storage_[1];
  NSString *customizationId;
  NSString *logoBlobId;
  NSMutableDictionary *colors;
} Customization__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "customizationId",
        .dataTypeSpecific.className = NULL,
        .number = Customization_FieldNumber_CustomizationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Customization__storage_, customizationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logoBlobId",
        .dataTypeSpecific.className = NULL,
        .number = Customization_FieldNumber_LogoBlobId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Customization__storage_, logoBlobId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "colors",
        .dataTypeSpecific.className = NULL,
        .number = Customization_FieldNumber_Colors,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Customization__storage_, colors),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Customization class]
                                     rootClass:[MemberRoot class]
                                          file:MemberRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Customization__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
